#!/usr/bin/perl

use strict;
use warnings;
use encoding 'utf-8';

use Global qw(/./);
use JSON;
use LWP;
use LWP::UserAgent;
use Digest::SHA qw(sha512_hex);
use Secrets;
use XML::Simple;
use Data::Dumper;

# this is just for the paranoid: hardcode the valid certificates, so rouge CAs don't concern us
my %goodCerts = (
  'e0afa607ec8264ab8134043672aa7c2bb617d4160cec998cbf9597ce759b1f9b4fe84c811ac6f2b5fc9590142ee6fe8812a936ce506d5d305d979ec275f15295' => 1,
  '4edf1edc86fb5a2d25a3e4891a14f7981529ad5052185a7d81d7700d847c2a1d74cee8c8731c1c335b85b8b8dda8b81ad03e1d1754271cbcff647c5b110f9907' => 1,
  '0b870e54f7bc1405107bfc9e45148c64860630f2f5dfe91d6c0f620e88e9ba3c729a94e07229238abb002052aa4a38ec4faf9a79b4b5062bedc966798d6d7312' => 1,
  'bd5041200fb99b8bba96ca23091c4c14ccd89e42a27b85543eab193736674ff75d7a922a2eccb7a93ac4907658b25eee26f32d95eca18103bf65b57c0c5f6911' => 1,
  '1e9346f8fdc9e901e4846fdfc7defaba5a514b2422d60433fa9c63c36b729db8c549c3b1c1c6696528d2727045585e6d91ec7fc86ebd64f764295e8f62d199fb' => 1,
  '25fa0d2f2ef252962e2c26f1a03ac9a630a2d782bbb3f42b6c15cedcd6e8d1190ed4d0c1f781808e553e20b8b146c3871511b9aae2b50d3df3b55b41bc0d8345' => 1,
);

my %names = (
  'agtechnik' => {
    'project' => 'https://ticket.piraten-nds.de/projects/agtechnik',
    'issues' => 'https://ticket.piraten-nds.de/issues',
  },
  'vorstand' => {
    'project' => 'https://ticket.piraten-nds.de/projects/vorstand',
    'issues' => 'https://ticket.piraten-nds.de/issues',
  },
  'helenastodo' => {
    'project' => 'https://ticket.piraten-nds.de/projects/helenastodo',
    'issues' => 'https://ticket.piraten-nds.de/issues',
  },
  'bewerbungen' => {
    'project' => 'http://flfy.de/redmine/projects/bewerbungen',
    'issues' => 'http://flfy.de/redmine/issues',
  },
);

my %pullFor = (
  'Helena Schmidt' => 1,
);

my %utilities = (
  'agtechnik.Niedrig' => 0.8,
  'agtechnik.Normal' => 2,
  'agtechnik.Hoch' => 4,
  'agtechnik.Sofort' => 10,
  'helenastodo.Niedrig' => 0.8,
  'helenastodo.Normal' => 2,
  'helenastodo.Hoch' => 5.1,
  'helenastodo.Sofort' => 15,
  'vorstand.Niedrig' => 0.8,
  'vorstand.Normal' => 2,
  'vorstand.Hoch' => 5,
  'vorstand.Sofort' => 12,
  'bewerbungen.Niedrig' => 0.8,
  'bewerbungen.Normal' => 2,
  'bewerbungen.Hoch' => 4,
  'bewerbungen.Sofort' => 10,
);

my %locations = (
  'agtechnik' => ['slice_pirates'],
  'helenastodo' => ['slice_pirates'],
  'vorstand' => ['slice_pirates'],
  'bewerbungen' => ['slice_work'],
);

my $project = $ARGV[0] or die help();
my $base = $names{$project} or die "No such project configured: $project";
my $externalBase = 'redmine://' . [$base->{'issues'} =~ m!^https://(.*)$!]->[0];
my $action = $ARGV[1] or die help();
my $key = Secrets::redmineAPIKey($base->{'project'});

my $ua = LWP::UserAgent->new;
$ua->agent("Utilator Redmine Bridge");
$ua->ssl_opts( SSL_verify_mode => 2 );
$ua->ssl_opts( SSL_verify_callback => \&verifyCert );

if($action eq "pull") {
  my @issues;
  my @fetchedIssues;
  my $offset = 0;
  do {
    @fetchedIssues = ();

    my $xml = XMLin(http('GET' => "$base->{'project'}/issues.xml?key=$key&offset=$offset&limit=100"));
    foreach my $key (keys %{$xml->{'issue'}}) {
      push @fetchedIssues, {
        %{$xml->{'issue'}->{$key}},
        'id' => $key,
      };
    }
    push @issues, @fetchedIssues;

    $offset += $xml->{'limit'};
  } while(@fetchedIssues);

  # print Dumper(@issues);

  my $now = iso_full_date(time);

  foreach my $issue (@issues) {
    next if($issue->{'assigned_to'} and not $pullFor{$issue->{'assigned_to'}->{'name'}});
    next if($issue->{'start_date'} gt $now);
    next if($issue->{'status'}->{'name'} eq 'Erledigt');
    next if($issue->{'status'}->{'name'} eq 'Fehlgeschlagen');
    next if(exists $issue->{'category'} and $issue->{'category'}->{'name'} eq 'Info');
    
    my @tasks = @{dbh()->selectall_arrayref(<<EOSQL, { Slice => {} }, $externalBase . '/' . $issue->{'id'})};
    SELECT * FROM task t WHERE EXISTS (SELECT 1 FROM task_external e WHERE e.task = t.id AND e.external = ?) AND t.status < 100
EOSQL

    if(@tasks) {
      my $task = $tasks[0];

      next if $task->{'last_edit'} ge $issue->{'updated_on'};

      my $title = $task->{'title'};
      my $utility = $utilities{$project . '.' . $issue->{'priority'}->{'name'}};
      my $seconds_estimate = (ref $issue->{'estimated_hours'} ne 'HASH')? $issue->{'estimated_hours'} * 3600: undef;
      my $status = $issue->{'done_ratio'};

      if($status < 0 or $status >= 100) {
        $status = 0;
      }

      if(not defined $seconds_estimate) {
        $title .= ': Zeitsch채tzung';
        $seconds_estimate = 60;
      }

      if(not defined $utility) {
        $title = "Utilator: Redmine-Utility-Definition f체r '" . $project . '.' . $issue->{'priority'}->{'name'} ."' fixen.";
        $utility = 4;
      }

      print "Updating task for " . $issue->{'subject'} . "\n";

      dbh()->do(<<EOSQL, {}, $title, $seconds_estimate, $status, $now, $task->{'gid'});
        UPDATE task SET title = ?, seconds_estimate = ?, status = ?, last_edit = ? WHERE gid = ?
EOSQL

      dbh()->do(<<EOSQL, {}, $task->{'id'});
        DELETE FROM task_utility WHERE task = ?
EOSQL
      dbh()->do(<<EOSQL, {}, $task->{'id'}, "0constant:" . int($utility * 1000));
        INSERT INTO task_utility (task, distribution) VALUES (?, ?)
EOSQL
    } else {
      my $issueId = $issue->{'id'};
      my $xmlDetail = XMLin(http('GET' => "$base->{'issues'}/$issueId.xml?key=$key&include=children"));
      next if($xmlDetail->{'children'});

      my $gid = create_gid();
      my $author = $issue->{'author'}->{'name'};
      my $title = "Redmine-Ticket '$issue->{'subject'}' bearbeiten";
      my $utility = $utilities{$project . '.' . $issue->{'priority'}->{'name'}};
      my $seconds_estimate = (ref $issue->{'estimated_hours'} ne 'HASH')? $issue->{'estimated_hours'} * 3600: undef;
      my $publication = PUBLICATION_PRIVATE;
      my $status = $issue->{'done_ratio'};

      next if $status == 100;

      if($status < 0 or $status >= 100) {
        $status = 0;
      }

      if(not defined $seconds_estimate) {
        $title .= ': Zeitsch채tzung';
        $seconds_estimate = 60;
      }
#    if(not defined $issue->{'assigned_to'}) {
#      $title .= ': Zuweisen';
#      $seconds_estimate = 60;
#    }

      if(not defined $utility) {
        $title = "Utilator: Redmine-Utility-Definition f체r '" . $project . '.' . $issue->{'priority'}->{'name'} ."' fixen.";
        $utility = 4;
      }

      my @validLocations;
      foreach my $loc (@{$locations{$project}}) {
        my @rows = @{dbh()->selectall_arrayref(<<EOSQL, { Slice => {} }, $loc)};
        SELECT * FROM space_active WHERE name = ?
EOSQL
        if(@rows) {
          push @validLocations, $loc;
        } else {
          $title .= "Utilator: Redmine-Locations definition needs to be fixed: $loc";
          $seconds_estimate = 60;
        }
      }

      print "Creating task for " . $issue->{'subject'} . "\n";

      dbh()->do(<<EOSQL, {}, $gid, $author, $title, $seconds_estimate, 0, $status, $publication, $now);
        INSERT INTO task (gid, author, title, seconds_estimate, seconds_taken, status, publication, last_edit) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
EOSQL

      my $id = dbh()->selectall_arrayref(<<EOSQL, { Slice => {} }, $gid)->[0]->{'id'};
        SELECT id FROM task WHERE gid = ?
EOSQL

      dbh()->do(<<EOSQL, {}, $id, "0constant:" . int($utility * 1000));
        INSERT INTO task_utility (task, distribution) VALUES (?, ?)
EOSQL

      dbh()->do(<<EOSQL, {}, $id, $externalBase . '/' . $issue->{'id'});
        INSERT INTO task_external (task, external) VALUES (?, ?)
EOSQL

      foreach my $loc (@validLocations) {
        dbh()->do(<<EOSQL, {}, $gid, $loc);
        INSERT INTO task_likelyhood_space (task, distribution) VALUES ((SELECT id FROM task WHERE gid = ?), ?)
EOSQL
      }
    }
  }
} else {
  die help();
}

sub help {
  my $ret = <<EOTXT;
./redmine <project> <action> ...
  pull - query the redmine for assigned tasks no todo exists for

valid projects:
EOTXT

  foreach my $project (keys %names) {
    $ret .= "  " . $project . " => " . $names{$project} . "\n";
  }

  return $ret;
}

sub verifyCert {
  my $sslLibThinksOk = $_[1];

  my $sha512 = sha512_hex(Net::SSLeay::PEM_get_string_X509($_[4]));

  # warn $sha512;
  # modify this line depending on how you would like your certificate to be checked
  return $goodCerts{$sha512} and $sslLibThinksOk;
}

sub http {
  my ($method, $url) = @_;

  # print "$method $url\n";

  my $req = HTTP::Request->new($method => $url);
  my $res = $ua->request($req);
  die $res->status_line() . IO::Socket::SSL::errstr() . ' @ ' . $url if(not $res->is_success());

  return $res->content();
}
